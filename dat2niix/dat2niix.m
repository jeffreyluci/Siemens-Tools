function dat2niix(dicomDirectory, datDirectory, niftiDirectory, options)
%dat2niix - A function that generates multi-echo NIfTI files from raw image
%           (pixel) data saved by WashU's NORDIC functor from the CMRR BOLD
%           EPI pulse sequence.
%
%Usage: dat2niix(dicomDirectory, datDirectory, niftiDirectory)
%       dat2niix(dicomDirectory, datDirectory, niftiDirectory, options)
%
%dicomDirectory: The full path to a directory that contains the DICOMs of
%                the first echo. If magnitude and phase data are saved,
%                each must be stored in individual and separate directories.
%
%datDirectory: The full path to a directory of all the raw image (*.dat)
%              files generated by the NORDIC functor. These dat files need
%              not be separated into different directories for each series
%              or for magnitude & phase data. Everything can exist in one
%              location, which is how they are saved on the scanner.
%
%niftiDirectory: The full path to the directory that will contain the new
%                NIfTI files. It is recomended that this folder be empty to
%                avoid confusion, but that is not required.
%
%Options: Verbose = true/(false) - verbose output to the command line
%         highPrecision = true/(false) - TE recorded in headers with 
%                         microsecond precision when set to true, otherwise
%                         the TE is recorded with (more common) tenth of a
%                         millisecond precision
%         reportTime = true/(false) - report the total time spent
%                                     processing the job
%         logFile = <log file> - A text file will be created at the 
%                                location of the log file specified at the 
%                                verbosity level specified. Note that this 
%                                file will be sparsely populated or even  
%                                empty for successful jobs with the Verbose
%                                option turned off. The default is no
%                                logging.
% 
% This function works in conjunction with both the CMRR multiband BOLD EPI 
% sequence and the WashU NORDIC recon functor to produce multi-echo, 
% compressed NIfTIs assembled from the raw image data saved on the scanner
% and header information gathered from both the DICOM of the first echo and
% the NIfTI generated by dcm2niix.
%
% This solution is meant to avoid resource spikes on the scanner host due
% to what is suspected to be lack of full support of multi-echo images from
% the CMRR BOLD EPI sequence. The NORDIC functor writes only the first echo
% to the host's database and routes the raw image data to a temporary
% location on the scanner's local drive. The raw images do not have any
% metadata associated with them, so dcm2niix is used to generate the first
% echo's header from the DICOM. This function uses the DICOM and the NIfTI
% from dcm2niix to assemble NIfTIs of all echos, one file per echo. 
%
% The multi-echo NIfTI headers contain the correct TE for their respecitve
% data and the slice timing parameters for all but the first echo have their
% respective TEs added to them. It is possible to force maximum precision
% recording of the TEs with the highPrecision logical argument.
%
% Two dependencies exist for this function. The package dcm2niix is
% maintained and distributed at <a href="matlab:web('https://github.com/rordenlab/dcm2niix')">Chris Rorden's GitHub.</a>
% The M-file parseMrProt.m is maintained and distributed at 
% <a href="matlab:web('https://github.com/jeffreyluci/Siemens-Tools/tree/main/parseMrProt')">Jeff Luci's GitHub.</a>
% All software called by or otherwise used by this M-file is subject to the
% license and citation requirements described on their respective GitHub pages.
%
%The NORDIC reconstruction functor (pipeline) is available at 
% <a href="matlab:web('https://webclient.us.api.teamplay.siemens-healthineers.com/c2p')">The Siemens Teamplay C2P Exchange.</a>
%
% This function is maintained <a href="matlab:web('https://github.com/jeffreyluci/Siemens-Tools/tree/main/dat2niix')">at this URL.</a>:
% Version: 20240201

% Author: Jeffrey Luci, jeffrey.luci@rutgers.edu
% https://github.com/jeffreyluci/Siemens-Tools/tree/main/dat2niix
% VERSION HISTORY:
% 20240201: Initial Release.
% 20240202: Added timed option and numerous comment improvements.
% 20240206: Added provenance notation in json sidecar to ConversionSoftware
%           and ConversionSoftwareVersion objects. Fixed time report bug.
% 20240219: Added logging feature. Changed NIfTI naming convention to make
%           it more BIDS-friendly. Added more verbose-level descriptive
%           text.
% 20240220: Added log filename automatic incrementing feature. Fixed bug
%           that prevented execution time from being written to log.
%           Corrected the logged filenames for the NIfTIs written to
%           include the full path name.


arguments
    dicomDirectory char
    datDirectory   char
    niftiDirectory char
    options.Verbose       (1,1) logical = false
    options.highPrecision (1,1) logical = false
    options.reportTime    (1,1) logical = false
    options.logFile       char = 'none'
end

VERSION = 'v20240220';

%enable execution time reporting if specifically requested
if options.Verbose || options.reportTime
    startTime = tic;
end

%log output if requested
if ~strcmp(options.logFile, 'none')
    options.logFile = incrementFilename(options.logFile);
    diary(options.logFile);
end        

%enable high precision parameters if requested
if options.highPrecision
    TEPrecision = '%0.3f';
else
    TEPrecision = '%0.1f';
end

%Check to ensure prerequisites are installed
checkDcm2niixVersion(options);
mrProtExists = exist('parseMrProt.m', 'file');
if mrProtExists ~= 2
    error('parseMrProt.m is not found in the path. See help for instructions.');
end


%Format directory names
if ~strcmp(niftiDirectory(end), filesep)
    niftiDirectory = sprintf('%s%c', niftiDirectory, filesep);
end
if ~strcmp(datDirectory(end), filesep)
    datDirectory = sprintf('%s%c', datDirectory, filesep);
end

%Check to ensure source and target directories exist
if ~exist(dicomDirectory, "dir")
    error('The directory %s is not found.', dicomDirectory);
elseif options.Verbose
    disp([dicomDirectory ' found.']);
end
if ~exist(datDirectory, "dir")
    error('The directory %s is not found.', datDirectory);
elseif options.Verbose
    disp([datDirectory ' found.']);
end
if ~exist(niftiDirectory, "dir")
    error('The directory %s is not found.', niftiDirectory);
elseif options.Verbose
    disp([niftiDirectory ' found.']);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 1 - Parse the DICOMs and get the information %
%          needed from the headers                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

d=dir(dicomDirectory);

%Assume all files in dicomDirectory are DICOMs, and initialize 
%the workList struct explicitly to ensure maximum efficency
workList(numel(dicomDirectory)-1).dicomName    = [];
workList(numel(dicomDirectory)-1).imgType      = [];
workList(numel(dicomDirectory)-1).repNum       = [];
workList(numel(dicomDirectory)-1).datFile      = [];
workList(numel(dicomDirectory)-1).seriesUID    = [];
workList(numel(dicomDirectory)-1).datFileMatch = [];


curDicom = 1;
for ii = 3:numel(d)
    curFile = fullfile(dicomDirectory, d(ii).name);
    if isdicom(curFile)
        workList(curDicom).dicomName = curFile;
        if options.Verbose
            disp(['Parsing: ' workList(curDicom).dicomName]);
        end
        hdr = dicominfo(workList(curDicom).dicomName);
        if contains(hdr.SeriesDescription, 'BOLD_NORDIC') %only select NORDIC DICOMs
            if strcmp(hdr.ComplexImageComponent, 'MAGNITUDE')
                if contains(hdr.SeriesDescription, 'SBRef')
                    workList(curDicom).imgType = 'mag_sbref';
                else
                    workList(curDicom).imgType = 'mag';
                end
            elseif strcmp(hdr.ComplexImageComponent, 'PHASE')
                if contains(hdr.SeriesDescription, 'SBRef')
                    workList(curDicom).imgType = 'phs_sbref';
                else
                    workList(curDicom).imgType = 'phs';
                end
            else
                error('Unknown data type in %s.', workList(curDicom).dicomName);
            end               
            workList(curDicom).repNum = hdr.InstanceNumber;
            workList(curDicom).datFile = 'pending';
            workList(curDicom).seriesUID = trimUID(hdr.SeriesInstanceUID);
            if curDicom == 1
                mrProt = parseMrProt(hdr);
            end
            curDicom = curDicom + 1;
        end
    end
end

%Warn user if DICOMs are not XA
if options.Verbose
    disp('Checking DICOM version for compatibility.');
end
if ~contains(hdr.ImplementationVersionName, 'XA')
    warning(['The DICOMs do not appear to be acquired using at least', newline, ...
            'the Syngo XA-line platform. This software was written', newline, ...
            'for XA-acquired enhanced DICOMs. Other verisons might', newline, ...
            'work, but it is not guaranteed, and you should take extra', newline, ...
            'precautions to ensure the results are as expected.']);
end


%Clean up workList by making sure the number of elements 
%is consistent with the number of DICOMs found. This is necessary since we
%assume above that all files in dicomDirectory are DICOMs. If that's not
%true, then the size of workList will be too long.
if numel(workList) > curDicom-1
    if options.Verbose
        disp(['Trimming of worklist is necessary.', newline, ...
              'This probably means there were non-DICOM files', newline, ...
              'in the DICOM directory. This should not matter.'])
    end
    workList(curDicom:end) = [];
end

numEchos  = mrProt.lContrasts;
TE        = mrProt.alTE(1:numEchos);
patientID = hdr.PatientID;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 2 - Match the DICOMs with the associated dat %
%          files - both mag and phs as appropriate  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for ii = 1:numel(workList)
    baseName = sprintf('%s%s_%s_', datDirectory, patientID);
    if strcmp(workList(ii).imgType, 'mag')
        workList(ii).datFile = sprintf('%s%s_Mag_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as MAGNITUDE images.')
        end
    elseif strcmp(workList(ii).imgType, 'phs')
        workList(ii).datFile = sprintf('%s%s_Phs_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as PHASE images.')
        end
    elseif strcmp(workList(ii).imgType, 'mag_sbref')
        workList(ii).datFile = sprintf('%s%s_SBRef_Mag_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as SBRef MAGNITUDE images.')
        end
    elseif strcmp(workList(ii).imgType, 'phs_sbref')
        workList(ii).datFile = sprintf('%s%s_SBRef_Phs_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as SBRef PHASE images.')
        end
    else
        error('Unknown Image data type.');
    end

    if exist(workList(ii).datFile, 'file')
        workList(ii).datFileMatch = true;
        if options.Verbose
            disp(['DICOM matched with ', workList(ii).datFile])
        end
    else
        workList(ii).datFileMatch = false;
        if options.Verbose
            disp(['Expected ', workList(ii).datFile, ' as dat file, but not found.'])
        end
    end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 3 - Call dcm2niix to generate the NIfTI files %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

if options.Verbose
    cmdString = ['dcm2niix -v y -z y -f %j -o ', niftiDirectory, ' ', dicomDirectory];
else
    cmdString = ['dcm2niix -z y -f %j -o ', niftiDirectory, ' ', dicomDirectory];
end
[~, STDOUT] = system(cmdString);
if options.Verbose
    disp(STDOUT)
end
if strcmp(workList(1).imgType, 'mag') || strcmp(workList(1).imgType, 'mag_sbref')
    niftiBaseName = hdr.SeriesInstanceUID;
elseif strcmp(workList(1).imgType, 'phs') || strcmp(workList(1).imgType, 'phs_sbref')
    niftiBaseName = [hdr.SeriesInstanceUID, '_ph'];
end
niftiTargetName = [niftiBaseName, '.nii.gz'];
if ~exist(fullfile(niftiDirectory,  niftiTargetName), 'file')
    error('dcm2niix failed to create the expected NIfTI file. Check the target directory.');
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 4 - Strip the header from the generated NIfTI   %
%          and use it to construct new NIfTI headers   %
%          for each echo of the data.                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

niftiHdr = niftiinfo(fullfile(niftiDirectory, niftiTargetName));
numPointsRead  = niftiHdr.ImageSize(1);
numPointsPhase = niftiHdr.ImageSize(2);
numSlices      = niftiHdr.ImageSize(3);
if length(niftiHdr.ImageSize)>3
numReps        = niftiHdr.ImageSize(4);
else
numReps=1;
end

%Prepare to edit the TE listed in the parent and raw descriptions
niftiDescription = split(niftiHdr.Description, ';');
TELocation = find(contains(niftiDescription, 'TE'));
niftiTE = split(niftiDescription{TELocation}, '=');

%Construct headers with correct echo times for all echos
%Precision of TE reported to a tenth of a millisecond by default,
%and to a microseond if requested in the options
for ii = 2:numEchos
    niftiHdr(ii) = niftiHdr(1);
    curTE = sprintf(TEPrecision, TE(ii)/1000);
    niftiTE{2} = curTE;
    TELine = char(join(niftiTE, '='));
    if options.Verbose
        disp(['Echo ', num2str(ii), ': ', TELine]);
    end
    niftiDescription{TELocation} = TELine;
    niftiHdr(ii).Description = char(join(niftiDescription, ';'));
    niftiHdr(ii).raw.descrip = niftiHdr(ii).Description;
end

%Read in raw data and reshape it to NIfTI dimensions
[~,repetitionOrder] = sort([workList.repNum]);
if options.Verbose && ~isequal(repetitionOrder, [workList.repNum])
    disp(['Repetitions are not written to DICOMs in chronological order.', newline, ...
          'It is HIGHLY recommended you check to ensure the sorted', newline, ...
          'images are in the correct order.', newline]);
end
rawIM = uint16(zeros(numPointsRead, numPointsPhase, numSlices, numEchos, numReps));

for ii = 1:numel(workList)
    if options.Verbose
        disp(['Reading: ', workList(repetitionOrder(ii)).datFile, ' to construct NIfTI.']);
    end
    fid = fopen(workList(repetitionOrder(ii)).datFile, 'rb');
    rawStream = fread(fid, inf, 'uint16');
    fclose(fid);
    rawStream = reshape(rawStream,[numPointsRead, numPointsPhase, numSlices, numEchos]);
    rawStream = flip(rawStream,2);
    %rawStream = permute(rawStream,[2 1 3 4]);
    %Assume interleaved slice ordering, but in the future other ordering
    %options might be enabled, in which case the slice order should be
    %determined from the DICOM header
    [~,sliceOrder] = sort([2:2:numSlices 1:2:numSlices-1]);
    rawStream = rawStream(:,:,sliceOrder,:);
    rawIM(:,:,:,:,ii) = rawStream;
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 5 - Write out new NIfTI files with modified headers %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

niftiNameBase = sprintf('%s_%s_%03d_', hdr.PatientID, ...
                                       replace(hdr.SeriesDescription, '_Pha', ''), ...
                                       hdr.SeriesNumber);
for ii = 1:numEchos
    if strcmp(workList(1).imgType, 'mag') || strcmp(workList(1).imgType, 'mag_sbref')
        nameAppendix = sprintf('_mag_echo-%02d', ii);
    elseif strcmp(workList(1).imgType, 'phs') || strcmp(workList(1).imgType, 'phs_sbref')
        nameAppendix = sprintf('_phs_echo-%02d', ii);
    end
    if strcmp(niftiNameBase(end), '_')
        niftiNameBase = niftiNameBase(1:end-1);
    end
    curName = [niftiNameBase, nameAppendix];
    if options.Verbose
        disp(['Writing: ', fullfile(niftiDirectory, strcat(curName, '.nii.gz'))]);
    end
    niftiwrite(squeeze(rawIM(:,:,:,ii,:)), fullfile(niftiDirectory, curName), ...
                                           niftiHdr(ii), 'Compressed', true);
end

%Clean up temporary NIfTI file from dcm2niix to avoid confusion
if options.Verbose
    disp('Removing temporary NIfTI file generated by dcm2niix.');
end
delete(fullfile(niftiDirectory,  niftiTargetName));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 6 - Write new json files with correct TE and slice  %
%          timing for each echo consistent with the NIfTI  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

jsonFilename = fullfile(niftiDirectory, [niftiBaseName, '.json']);
if options.Verbose
    disp(['Reading json file: ', jsonFilename]);
end
fid = fopen(jsonFilename, 'rt');
jsonContents = fread(fid, inf, 'uint8=>char')';
fclose(fid);
jsonStruct = jsondecode(jsonContents);

%update ConversionSoftware object to note this modification
convSoft = split(jsonStruct.ConversionSoftware);
convSoftVer = split(jsonStruct.ConversionSoftwareVersion);
convSoft{end+1} = 'dat2niix';
convSoftVer{end+1} = VERSION;
jsonStruct.ConversionSoftware = join(convSoft, ';');
jsonStruct.ConversionSoftwareVersion = join(convSoftVer, ';');

for ii = 1:numEchos
    jsonStruct(ii) = jsonStruct(1);

    %fix echo time
    jsonStruct(ii).EchoTime = str2double(sprintf('%0.4f', TE(ii)/10e6));
    jsonStruct(ii).SliceTiming = jsonStruct(1).SliceTiming + TE(ii)/10e6;

    curJsonTxt = jsonencode(jsonStruct(ii), PrettyPrint=true);
    if strcmp(workList(1).imgType, 'mag') || strcmp(workList(1).imgType, 'mag_sbref')
        nameAppendix = sprintf('_mag_echo-%02d', ii);
    elseif strcmp(workList(1).imgType, 'phs') || strcmp(workList(1).imgType, 'phs_sbref')
        nameAppendix = sprintf('_phs_echo-%02d', ii);
    end
    curName = fullfile(niftiDirectory, [niftiNameBase, nameAppendix]);
    if options.Verbose
        disp(['Writing new json file: ', curName]);
    end
    fid = fopen(curName, 'wt');
    fwrite(fid, curJsonTxt, 'uint8');
    fclose(fid);
end

%Clean up temporary NIfTI file from dcm2niix to avoid confusion
if options.Verbose
    disp('Removing temporary json file generated by dcm2niix.');
end
delete(jsonFilename);

%Report time spent
if options.Verbose || options.reportTime
    timeSpent = num2str(toc(startTime));
    disp(['Total time spent in process: ', timeSpent, ' sec.']);
end

%discontinue loging if enabled
if ~strcmp(options.logFile, 'none')
    diary('off');
end


end



function dateOfVersion = checkDcm2niixVersion(options)
        [STDERR,STDOUT] = system('dcm2niix -h');
        if STDERR ~= 0 
            error('Could not verify dcm2niix installation.');
        end
        if numel(STDOUT) < 5
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        if(options.Verbose)
            disp(STDOUT);
        end
        STDOUT = split(STDOUT, ' ');
        verStrLocation = find(contains(STDOUT, 'version'))+1;
        versionString = STDOUT{verStrLocation(1)};
        if numel(versionString) < 13
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        try
        versionMatrix = sscanf(versionString, 'v%d.%d.%d');
        dateOfVersion = datetime(num2str(versionMatrix(3)), 'InputFormat', 'yyyyMMdd');
        catch
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        if options.Verbose
            disp(['dcm2niix found, version dated: ', char(dateOfVersion)]);
        end

    end


    function newUID = trimUID(instanceUID)
    newUID = instanceUID;

        while strcmp(newUID(end-1:end), '.0')
            newUID = newUID(1:end-2);
        end
    end



    function newFilename = incrementFilename(oldFilename)

    %if the file does not exist, no increment is necessary,
    %so just return old filename.
    if ~exist(oldFilename, 'file')
        newFilename = oldFilename;
        return;
    end

    [filePath, fileName, fileExt] = fileparts(oldFilename);
    splitName = split(fileName, '-');
    fileNum = str2double(splitName{end});

    %if the split name contained a dash, and the last dash is only followed
    %by a number and the file extention, then increment the number
    if numel(splitName) > 2 && ~isnan(fileNum)
        fileNum = fileNum + 1;
        splitName{end} = num2str(fileNum);
        newFilename = fullfile(filePath, strcat(join(splitName, '-'), fileExt));

        %check to see if the new filename exists, and if it does, continue to
        %increment the number until a unique filename results
        while exist(newFilename, 'file')
            fileNum = fileNum + 1;
            splitName{end} = num2str(fileNum);
            newFilename = fullfile(filePath, strcat(join(splitName, '-'), fileExt));
        end
    else

        %if the filename does not end in a dash then number, then simply append
        %it with '-1'
        newFilename = fullfile(filePath, strcat([fileName, '-1'], fileExt));
    end

    end
